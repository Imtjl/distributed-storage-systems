# Подготовка к рубежной работе по РСХД

## Архитектура PostgreSQL

### ANSI-SPARC

Это трёхуровневая модель архитектуры СУБД:

1. `Внешний (пользовательский) уровень` - представляет данные так, как их видят
   конечные пользователи:

- Реализуется через представления (views)
- пользовательские запросы и интерфейсы
- разные пользователи могут видеть разные представления одних и тех же данных

2. `Промежуточный (концептуальный/логический) уровень` - описывает структуру
   всей базы данных:

- Реализуется через схемы, теблицы, отношения
- Определяет логическую структуру данных (столбцы, типы данных, связи)
- Не зависит от физического хранения

3. `Внутренний (физический) уровень` - описывает как данные физически хранятся:

- Реализуется через файлы данных, индексы, WAL
- Управление страницами и блоками
- Стратегии хранения и доступа к данным

PostgreSQL, как и все современные СУБД, следует этой модели:

1. Пользователь видит таблицы и представления (внешний уровень)
2. Администратор определяет схемы и отношения (концептуальный уровень)
3. Система управляет табличными пространствами, файлами, индексами (внутренний
   уровень)

### Архитектура СУБД

#### Процессы СУБД

- `postmaster`: представляет сервер PostgreSQL. Отвечает за запуск/остановку,
  создаёт серверные процессы (_postgres_) для обработки соединений, управляет
  данными одного кластера бд
- `postgres`: обрабатывает конкретное клиентское соединение
- `checkpointer`: создаёт контрольные точки - синхронизация WAL с диском, запись
  "грязных" страниц на диск, фиксация в логах.
- `background writer`: записывает изменённые страницы из SB (shared buffers) на
  диск в файлы данных
- `WAL writer`: записывает записи WAL буфера на диск
- `archiver`: копирует WAL файлы в указанное место
- `logging collector`: stderr -> логи
- `stats collector`: собирает статистику в промежуточные файлы для использования
  другими процессами -> pg*stat*\*

#### Разделяемая память PostgreSQL

Это сегмент RAM, доступный всем процессам PostgreSQL. Он используется для
различных буферов:

- `Shared buffers` (разделяемое буферное _пространство_) - Настраивается через
  _shared_buffers_, 128 MB по умолчанию. Хранит копии страниц (блоков данных),
  считанных из файлов данных.
- `WAL buffers` - буфер, работающий на уровне кластера бд, обеспечивающий
  Durability. Подробнее далее.
- `CLOG buffers` - Commit LOG, буфер для хранения данных о статусе проведения
  транзакций.
- `Lock space` - буфер для хранения данных о блокировках, использующихся
  экземпляром БД.

### WAL

WAL (Write Ahead Log) - техология обеспечения сохранности данных при сбоях.

По сути это буфер, работающий на уровне кластера бд, в который записываются все
изменения. Транзакция считается зафиксированной после сохранения WAL-записей на
диск с помощью системного вызова `fsync()` для гарантии того, что данные
действительно записаны на диск, а не лежат в кэше ОС.

#### Принцип работы

Каждой записи (т.е. каждому изменению) присваивается свой **LSN**. WAL буферы
хранятся в разделяемой памяти. Процесс WAL writer записывает эти буферы на диск.
При сбое система может восстановить изменения по WAL.

#### LSN (Log Sequence Number)

Это указатель на запись в WAL-журнале. Прерставляет собой 64-битное число.

#### Контрольная точка (checkpoint)

Точка в последовательности транзакций, в которую произведена синхронизация
результатов выполненных операций с файлами на диске.

Создаётся процессом `checkpointer` в двух случаях:

1. Заполнен WAL буфер (`max_wal_size`)
2. Через время `checkpoint_timeout` (дефолт 300с.)

#### Восстановление после сбоев

При запуске постгрес проверяет, был ли предыдущий экземпляр остановлен
корректно. Если нет, то начинается процесс восстановления - постгрес читает
WAL-файлы, начиная с последней контрольной точки, применяет изменения, которые
не были записаны в файлах.

Типы восстановления:

- Crash recovery: автоматическое, после сбоя
- Point in time recovery (PITR): на определённый момент времени
- Streaming replication: репликация на основе WAL

#### UNDO / REDO журналы

## Кластер PostgreSQL

### Файловая структура

#### PGDATA

Это директория, содержащая все файлы кластера бд:

```
$PGDATA/
├── base/             # Файлы данных баз
│   ├── 1/            # База postgres (OID=1)
│   ├── 13267/        # Другая база (с OID=13267)
├── global/           # Глобальные объекты кластера
├── pg_wal/           # WAL файлы (раньше pg_xlog)
├── pg_xact/          # Данные о транзакциях (CLOG)
├── pg_multixact/     # Данные о мультитранзакциях
├── pg_subtrans/      # Данные о вложенных транзакциях
├── pg_replslot/      # Данные слотов репликации
├── pg_twophase/      # Данные о двухфазных транзакциях
├── pg_snapshots/     # Экспортированные снимки
├── pg_stat_tmp/      # Временные статистические файлы
├── pg_tblspc/        # Символические ссылки на табличные пространства
├── postgresql.conf   # Основной конфиг кластера
├── pg_hba.conf       # Конфиг аутентификации
└── pg_ident.conf     # Конфиг сопоставления пользователей
```

#### Табличные пространства

Это физическое расположение файлов бд в фс.

Надо чтоб распределить нагрузки между физическими накопителями, управлять
размером кластера свыше предела фс, <ins>оптимизировать производительность<\ins>

##### Стандартные табличные пространства:

- `pg_default`: PGDATA/base
- `pg_global`: PGDATA/global

##### Создание и использование:

```sql
-- создаём табличное пространство
create tablespace myspace location '/tmp/myspace';

-- указываем конкретное табл. пр-во при создании таблички
create table mytable (id int) tablespace fastspace;

-- создастся в pg_default табл. пр-ве
create table mytable (id int);

-- просмотр созданных табличных пространств
\db
```

### Логическая структура

`кластер бд` -> `бд` -> `схема` -> `таблица и др. объекты`

> [!NOTE]  
> Экземпляр = процессы + память  
> Кластер = данные + файлы
>
> Кластер может существовать на диске без запущенного экземпляра (когда сервер
> остановлен) => `кластер` - физические данные, а `экземпляр` - процессы,
> работающие с ними

#### Кластер бд

Это набор баз данных под управлением одного сервера.

- Содержит глобальные объекты: роли, табличные пространства
- Фактически является директории PGDATA

#### База данных

Это набор схем.

- Физически соответствует поддиректории в PGDATA/base
- Соединение клиента всегда с конкретной бд
- Изолированное пространство имён

#### Схема

Это логическая группировка объектов

- Именованное пространство имен внутри бд
- По умолчанию есть схема 'public'
- Объекты в разных схемах могут иметь одинаковые имена

По умолчанию все объекты попадают в схему `public`. Есть также и другие схемы:

- `pg_catalog` - системные таблицы и представления
- `information_schema` - набор представлений с метаданными
- `pg_toast` - схема хранения больших объектов
- `pg_temp` - временные объекты

##### Посмотреть схемы можно так:

```sql
-- с помощью команды psql
\dn

-- найти в information_schema
select schema_name from information_schema.schemata;
```

##### search_path

Это последовательность схем, которая будет использоваться для идентификации
объекта при использовании неполного имени.

По умолчанию сначала ищет в схеме, совпадающей с именем текущего пользователя. А
затем в схеме `public`.

```sql
-- создание схемы
create schema studs

-- с указанием конкретной схемы
create table studs.mytable (id int);

-- без указания конкретной схемы
-- будет использована первая схема из search_path -> public
create table mytable (id int)l
```

##### Системный каталог

- `pg_catalog` - схема в каждой бд, в которой содержатся таблицы и
  представления.

##### Information schema

Набор представлений (views), через которые можно получить данные из системных
каталогов.

e.g. просто удобный интерфейс для доступа к данным

#### Таблица, индексы, функции, ...

- Хранят непосредственно данные
- Полное имя: `база.схема.таблица`

##### Системные каталоги

`pg_database`, `pg_class`, `pg_tables` - таблицы и представления в `pg_catalog`

```sql
-- или так
select * from pg_catalog.pg_class;
select * from pg_catalog.pg_tables;

-- или так
select * from pg_database;
```

### Конфигурация

- postgresql.conf
- pg_hba.conf
- Динамические параметры

### Конфигурационные утилиты (управление сервером)

- pg_ctl
- pg_reload_conf()

### Системные таблицы

- pg_class
- pg_attribute
- pg_database
- pg_roles

### Information schema

- стандартный интерфейс к метаданным
- отличие от системных каталогов

### OID, filenode

- как находить объекты по OID
- связь OID и фс

## Транзакции

`Транзакция` - логическая единица работы с данными. Объединяет
последовательность действий в одну операцию.

### Виды транзакций

Транзакции бывают `явные` и `неявные`. Явные пользователь задаёт самостоятельно
через `BEGIN`, `COMMIT` и т.п. Если нет явного указания начала транзакции, то
ЛЮБОЙ запрос выполняется в рамках _неявной_ транзакции.

### Команды управления транзакциями

```sql
-- Начало транзакции
BEGIN; -- или START TRANSACTION;

-- Инициируем изменение
UPDATE studs.groups SET exam_name = 'april_fools' WHERE max_score = 100;
-- На данном этапе изменения не применились сразу, а буферизировались в памяти и WAL

-- Фиксация изменений - применяем изменения к бд
COMMIT;

-- очередные изменения
UPDATE studs.exams SET ......
UPDATE studs.groups SET ......

-- Отбрасываем созданные изменения
ROLLBACK;

-- Создание точки сохранения внутри транзакции
SAVEPOINT имя_точки;

-- Откат к точке сохранения
ROLLBACK TO имя_точки;
```

### ACID

Это набор свойств, гарантирующих надёжную обработку транзакций.

1. **A**tomicity (Атомарность == **неделимость**): Транзакция выполняется
   полностью, либо не выполняется вообще.
   - Реализуется `Механизмом отложенных действий` - изменения не применяются
     сразу к данным, а буферизируются в памяти и в WAL-журнале. При COMMIT
     применяются к бд, а при ROLLBACK отбрасываются
2. **C**onsistency (Согласованность): Транзакция переводит БД из одного
   согласованного состояния в другое.
   - Реализуется ограничениями целостности (PK, FK, NOT NULL, CHECK, UNIQUE)
3. **I**solation (Изолированность): Конкурентно выполняющиеся транзакции
   изолированы и не влияют друг на друга.
   - Реализуется Lock'ами и _MVCC_
4. **D**urability (Долговечность): Результаты зафиксированной транзакции
   сохраняются даже при сбоях системы.
   - Реализуется WAL'ом

### Идентификация транзакций (xid)

### MVCC (SSI)

MVCC - Multi Version Concurrency Control

### Уровни изоляции

1. Read Uncommiteted (не поддерживается psql)
2. Read Committed (default): транзакция видит только зафиксированные изменения
3. Repeatable Read
4. Serializable

- аномалии транзакций

### VACUUM

- Принцип работы
- VACUUM vs VACUUM FULL
- avtovacuum

## Роли и привилегии

### Роли vs Пользователи

- Создание ролей и пользователей
- Атрибуты ролей (LOGIN, SUPERUSER, CREATEDB и др.)

### Группы ролей

- Наследование привилегий (INHERIT/NOINHERIT)
- Управление членством в группах

### Привилегии на объекты

- Типы привилегий (SELECT, INSERT, UPDATE и др.)
- GRANT/REVOKE
- WITH GRANT OPTION

### Практические примеры управления доступом

## Практика SQL

### Создание/изменение объектов

```sql
-- создание табличного пространства
create tablespace myspace location '/tmp/myspace';

-- создание схемы
create schema lol;

-- создание таблицы в указанной схеме и табличном пространстве
create table lol.kek (id smallint, meme varchar(40)) tablespace myspace;
```

### Управление привилегиями

### Запросы к системному каталогу

# Разбор прошлогоднего варианта

1. Setup THE EXACT evironment presented here:

| ![img](../docs/old-frontier.jpg) |
| -------------------------------- |

2. Run sql scripts, check behaviour, play around, research, memorize sql.
