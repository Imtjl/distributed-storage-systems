# Подготовка к рубежной работе по РСХД

## Архитектура PostgreSQL

### ANSI-SPARC

Это трёхуровневая модель архитектуры СУБД:

1. `Внешний (пользовательский) уровень` - представляет данные так, как их видят
   конечные пользователи:

- Реализуется через представления (views)
- пользовательские запросы и интерфейсы
- разные пользователи могут видеть разные представления одних и тех же данных

2. `Промежуточный (концептуальный/логический) уровень` - описывает структуру
   всей базы данных:

- Реализуется через схемы, теблицы, отношения
- Определяет логическую структуру данных (столбцы, типы данных, связи)
- Не зависит от физического хранения

3. `Внутренний (физический) уровень` - описывает как данные физически хранятся:

- Реализуется через файлы данных, индексы, WAL
- Управление страницами и блоками
- Стратегии хранения и доступа к данным

PostgreSQL, как и все современные СУБД, следует этой модели:

1. Пользователь видит таблицы и представления (внешний уровень)
2. Администратор определяет схемы и отношения (концептуальный уровень)
3. Система управляет табличными пространствами, файлами, индексами (внутренний
   уровень)

### Архитектура СУБД

#### Процессы СУБД

- `postmaster`: представляет сервер PostgreSQL. Отвечает за запуск/остановку,
  создаёт серверные процессы (_postgres_) для обработки соединений, управляет
  данными одного кластера бд
- `postgres`: обрабатывает конкретное клиентское соединение
- `checkpointer`: создаёт контрольные точки - синхронизация WAL с диском, запись
  "грязных" страниц на диск, фиксация в логах.
- `background writer`: записывает изменённые страницы из SB (shared buffers) на
  диск в файлы данных
- `WAL writer`: записывает записи WAL буфера на диск
- `archiver`: копирует WAL файлы в указанное место
- `logging collector`: stderr -> логи
- `stats collector`: собирает статистику в промежуточные файлы для использования
  другими процессами -> pg*stat*\*

#### Разделяемая память PostgreSQL

Это сегмент RAM, доступный всем процессам PostgreSQL. Он используется для
различных буферов:

- `Shared buffers` (разделяемое буферное _пространство_) - Настраивается через
  _shared_buffers_, 128 MB по умолчанию. Хранит копии страниц (блоков данных),
  считанных из файлов данных.
- `WAL buffers` - буфер, работающий на уровне кластера бд, обеспечивающий
  Durability. Подробнее далее.
- `CLOG buffers` - Commit LOG, буфер для хранения данных о статусе проведения
  транзакций.
- `Lock space` - буфер для хранения данных о блокировках, использующихся
  экземпляром БД.

### WAL

WAL (Write Ahead Log) - техология обеспечения сохранности данных при сбоях.

По сути это буфер, работающий на уровне кластера бд, в который записываются все
изменения. Транзакция считается зафиксированной после сохранения WAL-записей на
диск с помощью системного вызова `fsync()` для гарантии того, что данные
действительно записаны на диск, а не лежат в кэше ОС.

#### Принцип работы

Каждой записи (т.е. каждому изменению) присваивается свой **LSN**. WAL буферы
хранятся в разделяемой памяти. Процесс WAL writer записывает эти буферы на диск.
При сбое система может восстановить изменения по WAL.

#### LSN (Log Sequence Number)

Это указатель на запись в WAL-журнале. Прерставляет собой 64-битное число.

#### Контрольная точка (checkpoint)

Точка в последовательности транзакций, в которую произведена синхронизация
результатов выполненных операций с файлами на диске.

Создаётся процессом `checkpointer` в двух случаях:

1. Заполнен WAL буфер (`max_wal_size`)
2. Через время `checkpoint_timeout` (дефолт 300с.)

#### Восстановление после сбоев

При запуске постгрес проверяет, был ли предыдущий экземпляр остановлен
корректно. Если нет, то начинается процесс восстановления - постгрес читает
WAL-файлы, начиная с последней контрольной точки, применяет изменения, которые
не были записаны в файлах.

Типы восстановления:

- Crash recovery: автоматическое, после сбоя
- Point in time recovery (PITR): на определённый момент времени
- Streaming replication: репликация на основе WAL

#### UNDO / REDO журналы

## Кластер PostgreSQL

### Файловая структура

#### PGDATA

Это директория, содержащая все файлы кластера бд:

```
$PGDATA/
├── base/             # Файлы данных баз
│   ├── 1/            # База postgres (OID=1)
│   ├── 13267/        # Другая база (с OID=13267)
├── global/           # Глобальные объекты кластера
├── pg_wal/           # WAL файлы (раньше pg_xlog)
├── pg_xact/          # Данные о транзакциях (CLOG)
├── pg_multixact/     # Данные о мультитранзакциях
├── pg_subtrans/      # Данные о вложенных транзакциях
├── pg_replslot/      # Данные слотов репликации
├── pg_twophase/      # Данные о двухфазных транзакциях
├── pg_snapshots/     # Экспортированные снимки
├── pg_stat_tmp/      # Временные статистические файлы
├── pg_tblspc/        # Символические ссылки на табличные пространства
├── postgresql.conf   # Основной конфиг кластера
├── pg_hba.conf       # Конфиг аутентификации
└── pg_ident.conf     # Конфиг сопоставления пользователей
```

#### Табличные пространства

Это физическое расположение файлов бд в фс.

Надо чтоб распределить нагрузки между физическими накопителями, управлять
размером кластера свыше предела фс, <ins>оптимизировать производительность<\ins>

##### Стандартные табличные пространства:

- `pg_default`: PGDATA/base
- `pg_global`: PGDATA/global

##### Создание и использование:

```sql
-- создаём табличное пространство
create tablespace myspace location '/tmp/myspace';

-- указываем конкретное табл. пр-во при создании таблички
create table mytable (id int) tablespace fastspace;

-- создастся в pg_default табл. пр-ве
create table mytable (id int);

-- просмотр созданных табличных пространств
\db
```

### Логическая структура

`кластер бд` -> `бд` -> `схема` -> `таблица и др. объекты`

> [!NOTE]  
> Экземпляр = процессы + память  
> Кластер = данные + файлы
>
> Кластер может существовать на диске без запущенного экземпляра (когда сервер
> остановлен) => `кластер` - физические данные, а `экземпляр` - процессы,
> работающие с ними

#### Кластер бд

Это набор баз данных под управлением одного сервера.

- Содержит глобальные объекты: роли, табличные пространства
- Фактически является директории PGDATA

#### База данных

Это набор схем.

- Физически соответствует поддиректории в PGDATA/base
- Соединение клиента всегда с конкретной бд
- Изолированное пространство имён

#### Схема

Это логическая группировка объектов

- Именованное пространство имен внутри бд
- По умолчанию есть схема 'public'
- Объекты в разных схемах могут иметь одинаковые имена

По умолчанию все объекты попадают в схему `public`. Есть также и другие схемы:

- `pg_catalog` - системные таблицы и представления
- `information_schema` - набор представлений с метаданными
- `pg_toast` - схема хранения больших объектов
- `pg_temp` - временные объекты

##### Посмотреть схемы можно так:

```sql
-- с помощью команды psql
\dn

-- найти в information_schema
select schema_name from information_schema.schemata;
```

##### search_path

Это последовательность схем, которая будет использоваться для идентификации
объекта при использовании неполного имени.

По умолчанию сначала ищет в схеме, совпадающей с именем текущего пользователя. А
затем в схеме `public`.

```sql
-- создание схемы
create schema studs

-- с указанием конкретной схемы
create table studs.mytable (id int);

-- без указания конкретной схемы
-- будет использована первая схема из search_path -> public
create table mytable (id int)l
```

##### Системный каталог

- `pg_catalog` - схема в каждой бд, в которой содержатся таблицы и
  представления.

##### Information schema

Набор представлений (views), через которые можно получить данные из системных
каталогов.

e.g. просто удобный интерфейс для доступа к данным

```sql
\d information_schema.tables

.columns, .constraints, .schemata, .views, .routines
```

#### Таблица, индексы, функции, ...

- Хранят непосредственно данные
- Полное имя: `база.схема.таблица`

##### Системные каталоги

`pg_database`, `pg_roles`, `pg_attribute`, `pg_class`, `pg_tables` - таблицы и
представления в `pg_catalog`

```sql
-- или так
select * from pg_catalog.pg_class;
select * from pg_catalog.pg_tables;

-- или так
select * from pg_database;
```

### Конфигурация

- postgresql.conf
- pg_hba.conf
- Динамические параметры (SET)

### Конфигурационные утилиты (управление сервером)

- pg_ctl start/stop/reload
- pg_reload_conf()

### OID, filenode

OID - Object identifier

Уникальный числовой идентификатор объекта. Используется в системных каталогах
для ссылок на объекты. Есть специальные типы для разных объектов: gerclass для
таблиц, regproc для функций и т.п.

filenode - идентификатор файла на диске, соответствующего объекту БД обычно
совпадает с OID, но может отличаться после операций truncate/cluster

```
PGDATA/
└── base/
    └── 16384/  # OID базы данных
        └── 16385  # filenode таблицы
```

#### Поиск

```sql
-- Получить oid таблицы
select oid from pg_class
where relname = 'mytable'
and relnamespace = (
    select oid from pg_namespace where nspname = 'public'
);

-- Получить filenode таблицы
SELECT relfilenode FROM pg_class
WHERE relname = 'mytable'
AND relnamespace =
    (SELECT oid FROM pg_namespace WHERE nspname = 'public');
```

## Транзакции

`Транзакция` - логическая единица работы с данными. Объединяет
последовательность действий в одну операцию.

### Виды транзакций

Транзакции бывают `явные` и `неявные`. Явные пользователь задаёт самостоятельно
через `BEGIN`, `COMMIT` и т.п. Если нет явного указания начала транзакции, то
ЛЮБОЙ запрос выполняется в рамках _неявной_ транзакции.

### Команды управления транзакциями

```sql
-- Начало транзакции
BEGIN; -- или START TRANSACTION;

-- Инициируем изменение
UPDATE studs.groups SET exam_name = 'april_fools' WHERE max_score = 100;
-- На данном этапе изменения не применились сразу, а буферизировались в памяти и WAL

-- Фиксация изменений - применяем изменения к бд
COMMIT;

-- очередные изменения
UPDATE studs.exams SET ......
UPDATE studs.groups SET ......

-- Отбрасываем созданные изменения
ROLLBACK;

-- Создание точки сохранения внутри транзакции
SAVEPOINT имя_точки;

-- Откат к точке сохранения
ROLLBACK TO имя_точки;
```

### ACID

Это набор свойств, гарантирующих надёжную обработку транзакций.

1. **A**tomicity (Атомарность == **неделимость**): Транзакция выполняется
   полностью, либо не выполняется вообще.
   - Реализуется `Механизмом отложенных действий` - изменения не применяются
     сразу к данным, а буферизируются в памяти и в WAL-журнале. При COMMIT
     применяются к бд, а при ROLLBACK отбрасываются
2. **C**onsistency (Согласованность): Транзакция переводит БД из одного
   согласованного состояния в другое.
   - Реализуется ограничениями целостности (PK, FK, NOT NULL, CHECK, UNIQUE)
3. **I**solation (Изолированность): Конкурентно выполняющиеся транзакции
   изолированы и не влияют друг на друга.
   - Реализуется Lock'ами и _MVCC_
4. **D**urability (Долговечность): Результаты зафиксированной транзакции
   сохраняются даже при сбоях системы.
   - Реализуется WAL'ом

### Идентификация транзакций (xid)

### MVCC (SSI)

MVCC - Multi Version Concurrency Control

Механизм, обеспечивающей изолированность транзакций без блокировок чтения. На
каждую транзакцию создаётся "снимок" (snapshot) состояния бд.

#### Реализация в PostgreSQL

SSI - Serializable Snapshot Isolation

- При изменении данных в транзакции - создаётся новая копия данных
- Существующие - не изменяются
- При выборке - берётся подходящая для данной транзакции версия данных

### Изоляция транзакций

#### Виды конфликтов при параллельном доступе (аномалии транзакций)

1. Грязное чтение: транзакция видит незафиксированные изменения другой
   транзакции
2. Неповторяющееся чтение: один и тот же запрос в рамках транзакции возвращает
   разные результаты
3. Фантомное чтение: один и тот же запрос в рамках транзакции возвращает разное
   число записей

#### Уровни изоляции

1. Read Uncommiteted (не поддерживается psql)
2. Read Committed (default): транзакция видит только зафиксированные изменения
   - предотвращает грязное чтение
3. Repeatable Read
   - предотвращает грязное + неповторяющееся чтение
4. Serializable
   - предотвращает грязное + неповторяющееся + фантомное чтение, и аномалии
     сериализации

```sql
BEGIN TRANSACTION ISOLATION LEVEL SERIALIZABLE;
```

### VACUUM

- Принцип работы
- VACUUM vs VACUUM FULL
- avtovacuum

## Роли и привилегии

Привилегия - отражает конкретную возможность. Роль - именованный набор
привелегий.

Роль конфигурируется на уровне кластера, назначение и привилегии могут
отличаться для разных бд.

### Роли vs Пользователи

По сути, роли и пользователи - это одно и тоже. Разница только в атрибутах:

- Пользователь: роль с атрибутом LOGIN (может подключаться к бд)
- Роль: без атрибута LOGIN по умолчанию == группа привилегий

Пользователи могут быть созданы суперпользователем (postgres) и пользователем с
ролью CREATEROLE

#### Создание ролей и пользователей

```sql
-- создание роли
create role myrole;

-- создание пользователя (роль с LOGIN)
create user myuser with password '1234';

-- абсолютно эквивалентно:
create role myuser with login password 'password';
```

#### Атрибуты ролей

- `LOGIN/NOLOGIN` - разрешает/не разрешает подключаться к бд (пользователю)
- `SUPERUSER/NOSUPERUSER` - даёт/не даёт все привилегии
- `CREATEDB` - разрешает создавать бд
- `CREATEROLE` - создане других ролей
- `REPLICATION` - разрешает подключаться для репликации
- `Bypass RLS` - обходить политики защиты строк
- `PASSWORD` - устанавливает пароль
- `PASSWORD NULL` - запретить пользователю вход по паролю
- `CONNECTION LIMIT n` - ограничивает число подключений
- `VALID UNTIL` - срок действия пароли/роли

```sql
create role admin with login createdb createrole password 'secret1';

alter role myuser with createdb;
alter role myuser valid until '2026-12-31';

drop role myuser;
```

> [!NOTE]  
> Синтаксис `WITH` является полностью опциональным и может опускаться.

##### Итого, для подключения к бд надо иметь:

1. LOGIN
2. CONNECT на нужную бд
3. разрешение в pg_hba.conf

### Группы ролей

Роли можно объединять в группы для более удобного взаимодействия

```sql
-- создаём группу
create role devs;

-- добавляем пользователей к группе
grant devs to alice, bob;


grant devs to admin with admin option;
```

### Привилегии

Определяют, что может роль делать с объектами БД

- `SELECT` - чтение данных из таблицы/представления
- `INSERT` - добавление данных
- `UPDATE` - изменение данных
- `DELETE` - удаление данных
- `TRUNCATE` - очистка таблицы
- `REFERENCES` - создание внешнего ключа
- `TRIGGER` - создание триггера
- `CREATE` - создание объекта (схемы, таблицы и т.д.)
- `CONNECT` - подключение к БД
- `TEMPORARY` - создание временных таблиц
- `EXECUTE` - выполнение функции/процедуры
- `USAGE` - использование схемы, последовательности и т.д.
- `ALL PRIVILEGES` - все привилегии сразу

#### Наследование привилегий

- `INHERIT` - автоматическое наследование привелегий (по умолчанию):

```sql
create role dad login noinherit;
create role mom;
create role devs;

grant devs to mom; -- автоматическое наследование

grant devs to dad;
set role devs; -- явная активация привилегий группы
```

- Управление членством в группах

#### Предоставление привилегий

```sql
grant select, insert on mytable to myuser;
grant all privileges on database edu to student1;
grant select on studs to student1 with grant option;

create role devs;
-- этот студент теперь может управлять группой привилегий devs
grant devs to responsible_student with admin option;
```

## Практика SQL

### Создание/изменение объектов

```sql
-- создание табличного пространства
create tablespace myspace location '/tmp/myspace';

-- создание схемы
create schema lol;

-- создание таблицы в указанной схеме и табличном пространстве
create table lol.kek (id smallint, meme varchar(40)) tablespace myspace;
```

### Управление привилегиями

### Запросы к системному каталогу

# Разбор прошлогоднего варианта

1. Setup THE EXACT evironment presented here:

| ![img](../docs/old-frontier.jpg) |
| -------------------------------- |

2. Run sql scripts, check behaviour, play around, research, memorize sql.
