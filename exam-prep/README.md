We're preparing for exam here, watch out!

# Практические задания

## Пример задания на изоляции (рубежная работа, поток 2)

Есть 2 транзакции:

1. Read commited
2. Repeatable read

Изначально в БД 1 таблица Exams со следующими записями:

| ID  | Name | Classroom |
| --- | ---- | --------- |
| 1   | РСХД | 1405      |

Что будет выведено в результате выполнения запросов 1-4?

| Tx1                                             | Tx2                      |
| ----------------------------------------------- | ------------------------ |
| BEGIN READ COMMITED;                            |                          |
| 1. SELECT \* FROM Exams;                        |                          |
|                                                 | BEGIN REPEATABLE READ    |
| INSERT INTO Exams VALUES (2, 'ТПО', 1404)'      |                          |
| 2. SELECT \* FROM Exams;                        |                          |
|                                                 | 3. SELECT \* FROM Exams; |
| UPDATE Exams SET Classroom = 1404 WHERE ID = 1; |                          |
| COMMIT;                                         |                          |
|                                                 | 4. SELECT \* FROM Exams; |
|                                                 | COMMIT;                  |

<details>
<summary> Наивное объяснение уровнями изоляции </summary>

Вариант относительно простой. Нужно помнить, какие виды конфликтов параллельного
доступа к данным устраняет каждый уровень изоляции.

- Read commited: устраняет только грязное чтение
- Repeatable read: в общем случае устраняет грязное и неповторяющееся чтение, в
  случае Postgre (то есть как раз в нашем случае тоже) еще и фантомное

Соответственно:

**Запрос 1** вернет просто:

| ID  | Name | Classroom |
| --- | ---- | --------- |
| 1   | РСХД | 1405      |

**Запрос 2** вернет:

| ID  | Name | Classroom |
| --- | ---- | --------- |
| 1   | РСХД | 1405      |
| 2   | ТПО  | 1404      |

Так как в рамках той же траназакции, соответственно все норм

**Запрос 3** интереснее. Он уже в рамках второй транзакции, соответственно
потенциально возникает фантомное чтение. Транзакция с уровнем Repeatable,
соответственно этот конфликт она устраняет. Итого запрос вернет

| ID  | Name | Classroom |
| --- | ---- | --------- |
| 1   | РСХД | 1405      |

**Запрос 4** также в рамках второй транзакции. Потенциальный конфликт
неповторяющегося чтения, однако он тоже устраняется. То есть запрос вернет по
прежнему

| ID  | Name | Classroom |
| --- | ---- | --------- |
| 1   | РСХД | 1405      |

<h3> Подводные камни: </h3>

- Если бы транзакции поменялись местами, то ответ был бы другой, ибо Read
  commited менее строгая
- Типа Read Uncommited **НЕТ** в Постгре, однако в задании он может попасться. В
  таком случае считаем, что она Read Commited типа (можно конечно уточнить на
  самом экзамене, но однозначного ответа почти со 100% вероятностью не
  последует, так что лучше где-то рядом с ответом оставить пометку что
  рассматриваем с точки зрения Постгре)

</details>

<details>
<summary> Объяснение через MVCC и SI </summary>

1. Перед первым селектом tx1 создаётся снапшот, он видит (1, РСХД, 1405)

   - Далее выводится очев 1, РСХД, 1405

2. Перед вторым селектом tx1 был инсёрт, поэтому второй созданный снапшот видит
   две записи (старая + insert), т.к. на уровне READ COMMITTED перед каждым
   sql-предложением создаётся снапшот.

   - Далее в tx1 выводятся обе записи в табличке Exams

3. Согласно спеке постгреса, снапшот создаётся перед запросом/изменением данных,
   а не после begin, вопреки частому заблуждению.

> [!IMPORTANT]  
> НО! Так как транзакция tx1 всё ещё активна (в CLOG она `IN PROGRESS`, и её xid
> в Active XIDs), то созданный транзакцией tx2 снэпшот не содержит изменения
> tx1.

- Поэтому первый селект в tx2 выведет только одну запись в Exams, проигнорировав
  новую строчку с xid транзакции tx1, т.к. её просто не будет в снэпшоте

4. Надеюсь теперь всё встаёт на свои места. На уровне repeatable read снэпшот
   создаётся только один раз, поэтому даже несмотря на commit первой транзакции,
   снэпшот не будет обновляться, как на уровне read committed, и выведется то же
   самое, что и на прошлом селекте, т.е. только одна запись в Exams

</details>

## Задание на журнал по транзакции

Дана транзакция:

```sql
BEGIN T1;
INSERT INTO Exams (5, 'Java');
UPDATE EXAMS SET Name = 'Clojure' WHERE ID = 5;
COMMIT T1;
```

Распишите действия в транзакции в виде последовательности передачи данных между
различными пространствами памяти и составьте REDO лог (вариант 0) или UNDO лог
(вариант 1). Результат оформите в виде таблицы

| Операция | Диск | Журнал |
| -------- | ---- | ------ |

> Пример обозначений есть в лекциях

<details>
<summary> Выполнение с UNDO </summary>

| Операция            | Диск                 | Журнал                    |
| ------------------- | -------------------- | ------------------------- |
|                     |                      | BEGIN T1                  |
| -- insert           |                      |                           |
| vn = 'java', vi=5   |                      |                           |
| M(id5) <- T(vi, T1) |                      | T1: INSERT id5            |
| M(nm5) <- T(vn, T1) |                      | T1: INSERT nm5            |
| -- update           |                      |                           |
| T(vn, T1) <- M(nm5) |                      |                           |
| vn = 'clojure'      |                      |                           |
| M(nm5) <- T(vn, T1) |                      | T1: nm5, 'java'           |
| WriteLog            |                      | --запись на диск          |
| D <- M(id5)         | id5=5                |                           |
| D <- M(nm5)         | id5=5, nm5='Clojure' |                           |
|                     |                      | COMMIT T1                 |
| WriteLog            |                      | -- запись коммита на диск |

</details>

<details>
<summary> Выполнение с REDO </summary>

| Операция            | Диск                 | Журнал             |
| ------------------- | -------------------- | ------------------ |
|                     |                      | BEGIN T1           |
| vn = 'java', vi=5   |                      |                    |
| M(id5) <- T(vi, T1) |                      | T1: INSERT id5     |
| M(nm5) <- T(vn, T1) |                      | T1: INSERT nm5     |
| T(vn, T1) <- M(nm5) |                      |                    |
| vn = 'Clojure'      |                      |                    |
| M(nm5) <- T(vn, T1) |                      | T1: nm5, 'Clojure' |
|                     |                      | COMMIT T1          |
| WriteLog            |                      |                    |
| D <- M(id5)         | id5=5                |                    |
| D <- M(nm5)         | id5=5, nm5='Clojure' |

</details>
