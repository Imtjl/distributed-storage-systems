We're preparing for exam here, watch out!

# Практические задания

## Пример задания на изоляции (рубежная работа, поток 2)

Есть 2 транзакции:

1. Read commited
2. Repeatable read

Изначально в БД 1 таблица Exams со следующими записями:

| ID  | Name | Classroom |
| --- | ---- | --------- |
| 1   | РСХД | 1405      |

Что будет выведено в результате выполнения запросов 1-4?

| Tx1                                             | Tx2                      |
| ----------------------------------------------- | ------------------------ |
| BEGIN READ COMMITED;                            |                          |
| 1. SELECT \* FROM Exams;                        |                          |
|                                                 | BEGIN REPEATABLE READ    |
| INSERT INTO Exams VALUES (2, 'ТПО', 1404)'      |                          |
| 2. SELECT \* FROM Exams;                        |                          |
|                                                 | 3. SELECT \* FROM Exams; |
| UPDATE Exams SET Classroom = 1404 WHERE ID = 1; |                          |
| COMMIT;                                         |                          |
|                                                 | 4. SELECT \* FROM Exams; |
|                                                 | COMMIT;                  |

Вариант относительно простой. Нужно помнить, какие виды конфликтов параллельного
доступа к данным устраняет каждый уровень изоляции.

- Read commited: устраняет только грязное чтение
- Repeatable read: в общем случае устраняет грязное и неповторяющееся чтение, в
  случае Postgre (то есть как раз в нашем случае тоже) еще и фантомное

Соответственно:

**Запрос 1** вернет просто:

| ID  | Name | Classroom |
| --- | ---- | --------- |
| 1   | РСХД | 1405      |

**Запрос 2** вернет:

| ID  | Name | Classroom |
| --- | ---- | --------- |
| 1   | РСХД | 1405      |
| 2   | ТПО  | 1404      |

Так как в рамках той же траназакции, соответственно все норм

**Запрос 3** интереснее. Он уже в рамках второй транзакции, соответственно
потенциально возникает фантомное чтение. Транзакция с уровнем Repeatable,
соответственно этот конфликт она устраняет. Итого запрос вернет

| ID  | Name | Classroom |
| --- | ---- | --------- |
| 1   | РСХД | 1405      |

**Запрос 4** также в рамках второй транзакции. Потенциальный конфликт
неповторяющегося чтения, однако он тоже устраняется. То есть запрос вернет по
прежнему

| ID  | Name | Classroom |
| --- | ---- | --------- |
| 1   | РСХД | 1405      |

### Подводные камни:

- Если бы транзакции поменялись местами, то ответ был бы другой, ибо Read
  commited менее строгая
- Типа Read Uncommited **НЕТ** в Постгре, однако в задании он может попасться. В
  таком случае считаем, что она Read Commited типа (можно конечно уточнить на
  самом экзамене, но однозначного ответа почти со 100% вероятностью не
  последует, так что лучше где-то рядом с ответом оставить пометку что
  рассматриваем с точки зрения Постгре)

## Задание на журнал по транзакции

Дана транзакция:

```sql
BEGIN T1;
INSERT INTO Exams (5, 'Java');
UPDATE EXAMS SET Name = 'Clojure' WHERE ID = 5;
COMMIT T1;
```

Распишите действия в транзакции в виде последовательности передачи данных между
различными пространствами памяти и составьте REDO лог (вариант 0) или UNDO лог
(вариант 1). Результат оформите в виде таблицы

| Операция | Диск | Журнал |
| -------- | ---- | ------ |

> Пример обозначений есть в лекциях

<details>
<summary> Выполнение с UNDO </summary>

| Операция            | Диск                 | Журнал                    |
| ------------------- | -------------------- | ------------------------- |
|                     |                      | BEGIN T1                  |
| -- insert           |                      |                           |
| vn = 'java', vi=5   |                      |                           |
| M(id5) <- T(vi, T1) |                      | T1: INSERT id5            |
| M(nm5) <- T(vn, T1) |                      | T1: INSERT nm5            |
| -- update           |                      |                           |
| T(vn, T1) <- M(nm5) |                      |                           |
| vn = 'clojure'      |                      |                           |
| M(nm5) <- T(vn, T1) |                      | T1: nm5, 'java'           |
| WriteLog            |                      | --запись на диск          |
| D <- M(id5)         | id5=5                |                           |
| D <- M(nm5)         | id5=5, nm5='Clojure' |                           |
|                     |                      | COMMIT T1                 |
| WriteLog            |                      | -- запись коммита на диск |

</details>

<details>
<summary> Выполнение с REDO </summary>

| Операция            | Диск                 | Журнал             |
| ------------------- | -------------------- | ------------------ |
|                     |                      | BEGIN T1           |
| vn = 'java', vi=5   |                      |                    |
| M(id5) <- T(vi, T1) |                      | T1: INSERT id5     |
| M(nm5) <- T(vn, T1) |                      | T1: INSERT nm5     |
| T(vn, T1) <- M(nm5) |                      |                    |
| vn = 'Clojure'      |                      |                    |
| M(nm5) <- T(vn, T1) |                      | T1: nm5, 'Clojure' |
|                     |                      | COMMIT T1          |
| WriteLog            |                      |                    |
| D <- M(id5)         | id5=5                |                    |
| D <- M(nm5)         | id5=5, nm5='Clojure' |

</details>
